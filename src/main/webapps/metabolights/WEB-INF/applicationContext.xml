<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop 
           http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx 
           http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">

    <!-- the parent application context definition for the springapp application -->

	<!-- foo change, to play-learn with SVN- pconesa-->

    <bean id="productManager" class="uk.ac.ebi.metabolomes.springdemo.service.SimpleProductManager">
        <property name="productDao" ref="productDao"/>
    </bean>

    <bean id="productDao" class="uk.ac.ebi.metabolomes.springdemo.repository.JdbcProductDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 
    We also need to define a connection pool. We are using the DBCP connection pool from the Apache Jakarta project. 
    We are reusing the jdbc.properties file we created in Part 5.    
     -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <bean id="propertyConfigurer" 
          class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>classpath:jdbc.properties</value>
            </list>
        </property>
    </bean>


    <!-- 
    Any time you persist data in a database its best to use transactions to ensure that all your updates are perform or none 
    are completed. You want to avoid having half your updates persisted while the other half failed. Spring provides an extensive 
    range of options for how to provide transaction management. The reference manual covers this in depth. Here we will make use 
    of one way of providing this using AOP (Aspect Oriented Programming) in the form of a transaction advice and an ApectJ pointcut 
    to define where the transactions should be applied. 
    If you are interested in how this works in more depth, take a look at the reference manual. We are using the new namespace support 
    introduced in Spring 2.0. The "aop" and "tx" namespaces make the configuration entries much more concise compared to the traditional 
    way using regular "<bean>" entries.
    
    The pointcut applies to any method called on the ProductManager interface. The advice is a transaction advice that applies to methods
     with a name starting with save. The default transaction attributes of REQUIRED applies since no other attribute was specified. 
     The advice also applies "read-only" transactions on any other methods that are adviced via the pointcut.
     -->
    <bean id="transactionManager" 
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <aop:config>
        <aop:advisor pointcut="execution(* *..ProductManager.*(..))" advice-ref="txAdvice"/>
    </aop:config>

    <tx:advice id="txAdvice">
        <tx:attributes>
            <tx:method name="save*"/>
            <tx:method name="*" read-only="true"/>
        </tx:attributes>
    </tx:advice>

</beans>